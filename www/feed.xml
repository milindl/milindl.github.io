<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/www/feed.xml" rel="self" type="application/atom+xml" /><link href="/www/" rel="alternate" type="text/html" /><updated>2018-04-01T19:37:07+05:30</updated><id>/www/</id><title type="html">Milindâ€™s Writeups</title><subtitle>Hello, I'm an undergraduate student at IIT Kanpur. I'm going to use these pages to document any interesting stuff I think of, or anything I write, really.
</subtitle><entry><title type="html">Please Use GDB</title><link href="/www/2017/09/06/Please_use_gdb.html" rel="alternate" type="text/html" title="Please Use GDB" /><published>2017-09-06T00:00:00+05:30</published><updated>2017-09-06T00:00:00+05:30</updated><id>/www/2017/09/06/Please_use_gdb</id><content type="html" xml:base="/www/2017/09/06/Please_use_gdb.html">&lt;p&gt;&lt;i&gt;What this is not&lt;/i&gt;: a complete guide to &lt;code&gt;gdb&lt;/code&gt;. There are plenty of those
  online.
  This is primarily an opinion/experience piece on why &lt;i&gt;I&lt;/i&gt; find &lt;code&gt;gdb&lt;/code&gt; to be essential. There
  is &lt;i&gt;some&lt;/i&gt; usage instruction, but that is to enable anyone to follow along.&lt;/p&gt;
&lt;p&gt;The first programming language - or indeed, even the second one - I learnt
  was not C/C++. I never had to allocate any memory manually, or face any
  of those pesky segmentation faults. I had my friend the trusty GC with me,
  and I was happy. I first learnt C by bits-and-pieces &amp;#8211; in school, online, and finally, as a
  part of my academic curriculum at IIT Kanpur. At all those times, I found it
  to be tedious, boring, and needlessly hard to debug. I convinced myself that
  I&amp;#8217;d never ever use it.&lt;/p&gt;
&lt;h1&gt;Where did it all go wrong?&lt;/h1&gt;
&lt;p&gt;This section is not about my life in general, or about why I had to (finally) use C/C++. This
  is about the question that I asked myself the most while debugging my C/C++ programs.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Where did the segfault occur? Till where was the program successful? Where did it all go wrong?&lt;/i&gt;&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;C&quot;&gt;
void incrementPtrIncreaseValue(int **p, int n) {
  *p = (*p) + n;
  *p += 1;
}

int main() {
  int *x = (int *)malloc(sizeof(int) * 20);
  for (int i = 0; i &amp;lt; 20; i++) x[i] = i;
  int *ptr = x;
  for (int i = 0; i &amp;lt; 20; i++) {
    incrementPtrIncreaseValue(&amp;amp;ptr, 0);
    printf(&amp;quot;%d &amp;quot;, *(ptr - 1));
  }
  return 0;
}
&lt;/pre&gt;
&lt;p&gt;This is a program in which the function &lt;code&gt;incrementPtrIncreaseValue&lt;/code&gt; is supposed to increment
  the pointer passed to it, and increase the &lt;i&gt;value&lt;/i&gt; stored at the pointed location by &lt;code&gt;n&lt;/code&gt;. Then,
  we make an array &lt;code&gt;x = {0 ... 19}&lt;/code&gt; and loop over it, intending to increment every element.&lt;/p&gt;
&lt;p&gt;I don&amp;#8217;t know why you&amp;#8217;d write anything like it, but there&amp;#8217;s more &amp;#8211; this is incorrect. [0]&lt;/p&gt;
&lt;p&gt;To increment the pointer, &lt;code&gt;*p += 1&lt;/code&gt; is (correctly) used. However, to change the value, you need
  to use &lt;code&gt;**p&lt;/code&gt;, and in this case, since we&amp;#8217;ve used &lt;code&gt;*p&lt;/code&gt;, the &lt;i&gt;pointer&lt;/i&gt; is accidentally incremented by &lt;i&gt;n + 1&lt;/i&gt; and the value
  is unchanged.&lt;/p&gt;
&lt;p&gt;On an initial run, the program will work as expected - to test it out, you put &lt;code&gt;n = 0&lt;/code&gt;, so you didn&amp;#8217;t notice
  any issues with it. However, then you decide to increment by 10, and behold the output that follows (your mileage may vary a bit):&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
&lt;/pre&gt;
&lt;p&gt;&lt;i&gt;Ughh, the first element seems to be correct&lt;/i&gt;, you think, &lt;i&gt;where did I go wrong?&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;And to verify that your program is indeed totally and completely wrong, you replace 10 with a -2. (Again, your mileage may vary).&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
segmentation fault (core dumped)  ./executable_name
&lt;/pre&gt;
&lt;p&gt;You&amp;#8217;d probably be thinking that this particular error is rather trivial to fix &amp;#8211; and indeed, it is, but if there&amp;#8217;s also a lot of other code
  lying around, it is extremely hard to isolate the source of the error.&lt;/p&gt;
&lt;p&gt;[0] Please don&amp;#8217;t point out that I&amp;#8217;ve not included any standard libraries, even though it affects line numbering later. Deal with it, it&amp;#8217;s a non-issue.&lt;/p&gt;
&lt;h1&gt;&lt;code&gt;printf&lt;/code&gt; and copy-paste&lt;/h1&gt;
&lt;p&gt;My old go-to method for dealing with such errors was adding a bunch of &lt;code&gt;printf&lt;/code&gt; statements to the code, which would
  typically look like this: [1]&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;C&quot;&gt;
printf(&amp;quot;Reached uptill [linenum], with **ptr = %d&amp;quot;, **ptr);
&lt;/pre&gt;
&lt;p&gt;These would be littered in huge numbers around the lines I was suspicious of. Often, I would need to add these
  manually, since the content of the &lt;code&gt;printf&lt;/code&gt; statements would often depend on the statement preceding it.&lt;/p&gt;
&lt;p&gt;I think that anyone can understand why this is tedious, and why I perceived it as being difficult. I would often rewrite
  the whole code instead of trying to debug a segfault.&lt;/p&gt;
&lt;p&gt;[1] Observant readers will note that the code below is not well suited for cases where there is a crash, like a segfault,
  because &lt;code&gt;printf&lt;/code&gt; may cause the output to be &amp;#8216;buffered&amp;#8217; unless &lt;code&gt;fflush(stdout)&lt;/code&gt; is called or a &lt;code&gt;\n&lt;/code&gt; is encountered. I&amp;#8217;ve kept it like
  this deliberately since I often had troubles with this when I was starting off.&lt;/p&gt;
&lt;h1&gt;Enter &lt;code&gt;gdb&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;To actually use &lt;code&gt;gdb&lt;/code&gt;, you need to compile your program with &amp;#8216;debug symbols&amp;#8217;. Without those, &lt;code&gt;gdb&lt;/code&gt; cannot be very effective.
  This is because there&amp;#8217;s a lot of information that&amp;#8217;s lost while compiling, for instance, what memory location corresponds
  to what variable, and what line number in your source file corresponds to the code running in the executable.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;bash&quot;&gt;
$ gcc -g faultycode.c -o executable_name
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;-g&lt;/code&gt; flag takes care of the debug symbols. I also recommend that &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;optimizations&lt;/a&gt; be minimized during the compilation using the
  &lt;code&gt;-O0&lt;/code&gt; or &lt;code&gt;Og&lt;/code&gt; flag [2], since the compiler often decides that certain statements, like &lt;code&gt;x = x&lt;/code&gt; do not have any side effects, or certain variables
  are not needed (all those convenience variables we make to improve clarity of our code), and also &lt;a href=&quot;https://en.wikipedia.org/wiki/Inline_function&quot;&gt;inlines&lt;/a&gt; some functions. So, you can use
  either of the following statements.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;bash&quot;&gt;
$ gcc -g -O0 faultycode.c -o executable_name
$ gcc -g -Og faultycode.c -o executable_name
&lt;/pre&gt;
&lt;p&gt;And now, you&amp;#8217;re ready to start &lt;code&gt;gdb&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;bash&quot;&gt;
$ gdb ./executable_name
&lt;/pre&gt;
&lt;p&gt;[2] In certain cases, you might encounter an issue that is present &lt;i&gt;only&lt;/i&gt; in the optimized version, and the unoptimized version
  works fine. In such a case, this will not hold. I&amp;#8217;ve never been a victim of this, however, I&amp;#8217;ve often been a victim of the
  &lt;code&gt;$n = &amp;lt;optimized out&amp;gt;&lt;/code&gt; message which is printed out when a variable has been deemed unworthy by the compiler, so I stick to my
  idea of using the unoptimizing flags.&lt;/p&gt;
&lt;h1&gt;&lt;code&gt;break faultycode.c:11&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;What I do after this point is use something called a breakpoint. It&amp;#8217;s exactly what it sounds like - you can tell
  the program to stop executing when you encounter a particular line or function, and then you can&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Execute program line-by-line, to find out exactly &lt;i&gt;where did it all go wrong&lt;/i&gt;&lt;/li&gt;
  &lt;li&gt;Print values of any symbol in range&lt;/li&gt;
  &lt;li&gt;Print the stack trace&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And a lot more! But I&amp;#8217;ll focus on the first and the second one.&lt;/p&gt;
&lt;p&gt;Breakpoints can be set by line numbers, function names, and &lt;a href=&quot;ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html#SEC29&quot;&gt;a lot more.&lt;/a&gt; Let&amp;#8217;s set a breakpoint on the 11&lt;sup&gt;th&lt;/sup&gt; line of faultycode.c,
  and then start the program execution using &lt;code&gt;run&lt;/code&gt; (assume &lt;code&gt;n&lt;/code&gt; = 10 for this example).&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;shell&quot;&gt;
(gdb) break faultycode.c:11
Breakpoint 1 at 0xXXX: file faultycode.c, line 11.
(gdb) run
Breakpoint 1, main () at faultycode.c:11
11	    printf(&amp;quot;%d &amp;quot;, *(ptr - 1));
&lt;/pre&gt;
&lt;p&gt;Now that the breakpoint has been set, you can print anything.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;shell&quot;&gt;
(gdb) print *(ptr - 1)
$n = 10
(gdb) print *(ptr)
$n = 11
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ptr&lt;/code&gt; should be pointing to &lt;code&gt;x[1]&lt;/code&gt; at this moment, and the value should be 1. The value at &lt;code&gt;x[0]&lt;/code&gt; or &lt;code&gt;ptr - 1&lt;/code&gt; should
  be 10. On printing &lt;code&gt;*(ptr - 1)&lt;/code&gt;, we realize that the value is indeed 10, but printing &lt;code&gt;*ptr&lt;/code&gt;, we get 11, instead of the 1 that
  we expect. Is the pointer wrong somehow? Let&amp;#8217;s see, it &lt;code&gt;ptr - 1&lt;/code&gt; should be the same as &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;shell&quot;&gt;
(gdb) print x
$n = (int *) 0x555555756010
(gdb) print ptr
$n = (int *) 0x55555575603c
&lt;/pre&gt;
&lt;p&gt;Subtracting, we see that they differ by 40! How is that possible? &lt;code&gt;sizeof(int)&lt;/code&gt; is 4, so the pointer hex values differing by 40 means that
  they point to integers which are 40/4 = 10 memory locations apart. Indeed, when you print &lt;code&gt;ptr - 11&lt;/code&gt; you see that it is the same as &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, it seems like we have discovered the root of our problem: &lt;code&gt;ptr&lt;/code&gt; is incremented incorrectly somewhere. But, &lt;code&gt;incrementPtrIncreaseValue&lt;/code&gt; is the
  only place where we actually change that. So, let&amp;#8217;s step through that code and try to find out what is wrong. First, let&amp;#8217;s set a breakpoint on
  &lt;code&gt;incrementPtrIncreaseValue&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;shell&quot;&gt;
(gdb) break incrementPtrIncreaseValue
Breakpoint 2 at 0xXXX: file faultycode.c, line 2.
(gdb) continue
&lt;/pre&gt;
&lt;p&gt;Recall that currently, we are at a breakpoint, so program execution is halted. To start the program from where we stopped, &lt;code&gt;continue&lt;/code&gt; is used.
  Soon enough, the program will stop at the function, helpfully printing the parameters passed to it.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;shell&quot;&gt;
Breakpoint 2, incrementPtrIncreaseValue (p=0x7fffffffe608, n=10) at faultycode.c:2
2	  *p = (*p) + n;
&lt;/pre&gt;
&lt;p&gt;I&amp;#8217;m sure that the problem will be clear enough at this point, so that you can correct it. If not, then the following commands will help:&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
(gdb) print *p
$n = (int *) 0x55555575603c
(gdb) step
3	  *p += 1;
(gdb) print *p
$n = (int *) 0x555555756064
&lt;/pre&gt;
&lt;p&gt;I&amp;#8217;ll explain what happens - you stop &lt;i&gt;before&lt;/i&gt; executing the 2&lt;sup&gt;nd&lt;/sup&gt; line, and you print the value of &lt;code&gt;*p&lt;/code&gt;. Using &lt;code&gt;step&lt;/code&gt; [3] causes the execution
  of one line, so line 2 is executed, and you stop &lt;i&gt;before&lt;/i&gt; the execution of line 3. So, you can print &lt;code&gt;*p&lt;/code&gt; after the execution of line 2,
  and the error becomes clear on comparing the addresses. This step was not required in this case, since the error was easy to see, but
  you might be calling some function in line 2, which might have a long and convoluted way of modifying &lt;code&gt;p&lt;/code&gt;. In those cases, &lt;code&gt;step&lt;/code&gt; ping through
  the code is much easier.&lt;/p&gt;
&lt;p&gt;[3] In this case, &lt;code&gt;next&lt;/code&gt; would be equivalent to &lt;code&gt;step&lt;/code&gt; but the &lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html&quot;&gt;difference is really worth knowing.&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Go, Debug&lt;/h1&gt;
&lt;p&gt;I repeat again, &lt;b&gt;this is not a guide&lt;/b&gt;. Please see &lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html&quot;&gt;this comprehensive guide&lt;/a&gt;, or use &lt;code&gt;(gdb) help&lt;/code&gt; while inside &lt;code&gt;gdb&lt;/code&gt;, or &lt;a href=&quot;https://web.stanford.edu/class/cs107/guide_gdb.html&quot;&gt;this short guide.&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">What this is not: a complete guide to gdb. There are plenty of those online. This is primarily an opinion/experience piece on why I find gdb to be essential. There is some usage instruction, but that is to enable anyone to follow along.</summary></entry><entry><title type="html">NPC Name Generator</title><link href="/www/2017/06/01/NPC_name_generator.html" rel="alternate" type="text/html" title="NPC Name Generator" /><published>2017-06-01T00:00:00+05:30</published><updated>2017-06-01T00:00:00+05:30</updated><id>/www/2017/06/01/NPC_name_generator</id><content type="html" xml:base="/www/2017/06/01/NPC_name_generator.html">&lt;h1&gt;On NPC Names&lt;/h1&gt;
&lt;p&gt;An NPC, or a non-playing character in a computer or role-playing game is a character controlled by the game, who helps set the scene and progress the story. I&amp;#8217;ll be addressing NPCs which are a part of sci-fi or fantasy games. In my opinion, these NPCs should have names that deviate enough from regular, run-of-the-mill, &amp;#8220;Earthly&amp;#8221; names, and impart an unfamiliar and exotic feel to the setting. However, they should not have names which are contrived and do not have a realistic mouthfeel, like &amp;#8220;Tchu&amp;#8217;quixthal&amp;#8221;, or be too generic, like &amp;#8220;The Wise Sage&amp;#8221;.&lt;/p&gt;
&lt;p&gt;Diablo 2 is a game that gets it right in my opinion. Some examples are: Gheed, Akara, Charsi, Jerhyn.&lt;/p&gt;
&lt;p&gt;Now, the challenge here is to come up with names which are different, yet similar to &amp;#8220;Earthly&amp;#8221; names. My idea is to take a &amp;#8220;seed&amp;#8221; name, and generate variants of it to come up with NPC names. The inspiration for this derives from Isaac Asimov&amp;#8217;s &lt;i&gt;Caves of Steel&lt;/i&gt;, in which there is a character called &lt;i&gt;Daneel&lt;/i&gt;, whose name is similar enough to &lt;i&gt;Daniel&lt;/i&gt;, but yet exotic enough (for my tastes, at least!).&lt;/p&gt;
&lt;h1&gt;Generating Random Names&lt;/h1&gt;
&lt;p&gt;It&amp;#8217;s easy to generate random names of a particular length. Let&amp;#8217;s assume that it&amp;#8217;s also possible to rate names based on their closeness to another name. This rating is called the &lt;b&gt;score&lt;/b&gt;.  Using these two facts, and something called a genetic algorithm, I can come up with generated NPC names, and here&amp;#8217;s how:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Decide a &amp;#8220;seed&amp;#8221; name manually.&lt;/li&gt;
  &lt;li&gt;Generate a large number of random names with lengths close to the &amp;#8220;seed&amp;#8221; name.&lt;/li&gt;
  &lt;li&gt;Apply the genetic algorithm (explained below) to create a new list of names from the previous list.&lt;/li&gt;
  &lt;li&gt;Find out the &lt;b&gt;score&lt;/b&gt; of all names in the list to the &amp;#8220;seed&amp;#8221; name.&lt;/li&gt;
  &lt;li&gt;If we have a sufficient number of names whose &lt;b&gt;score&lt;/b&gt; is (say) above 0.9, print them, else repeat from 3.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given a list, a genetic algorithm drives us towards another list, which has an overall &lt;b&gt;score&lt;/b&gt; better than the current one, and it is the actual &amp;#8220;magic&amp;#8221; behind how the names are generated.&lt;/p&gt;
&lt;p&gt;A genetic algorithm is based loosely on how evolution works: the survival of the fittest.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Each animal in a &lt;b&gt;population&lt;/b&gt; has a &lt;b&gt;fitness&lt;/b&gt;.&lt;/li&gt;
  &lt;li&gt;Two (or more) animals can &lt;b&gt;mate&lt;/b&gt; to produce an offspring. Higher &lt;b&gt;fitness&lt;/b&gt; means that there is a higher chance that the animal will survive and &lt;b&gt;mate&lt;/b&gt;.&lt;/li&gt;
  &lt;li&gt;Each animal can also have a &lt;b&gt;mutation&lt;/b&gt; while producing offspring. This &lt;b&gt;mutation&lt;/b&gt; can be both good or bad in terms of how it affects the &lt;b&gt;fitness&lt;/b&gt; of the offspring.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In our scenario, the correspondence is such:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;population&lt;/b&gt; is the list of  names at the current moment.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;mating&lt;/b&gt; is the process of generating a new population of the same size based on the current one. The actual mating process is based on combination of names. For instance, &amp;#8220;milind&amp;#8221; and &amp;#8220;luthra&amp;#8221; can generate &amp;#8220;mi-thra&amp;#8221;, &amp;#8220;mil-hra&amp;#8221;, &amp;#8220;mili-ra&amp;#8221; and so on: the prefix of the generated name comes from the first name, and the suffix comes from the second name. If a name has a larger score, then it will contribute to more prefixes and suffixes in the new population.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;mutation&lt;/b&gt; is the process of random changes in a name, so &amp;#8220;milind&amp;#8221; can mutate to &amp;#8220;nilind&amp;#8221;. This is necessary because we can sometimes reach a &amp;#8220;plateau&amp;#8221; where no amount of mating can produce a better score. The probability of mutation is very low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you are interested in genetic algorithms and their implementation, &lt;a href=&quot;https://en.wikipedia.org/wiki/Genetic_algorithm&quot;&gt;read the wikipedia page&lt;/a&gt; and then try doing &lt;a href=&quot;https://www.codewars.com/kata/binary-genetic-algorithms/javascript&quot;&gt;this question&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Scoring Random Names&lt;/h1&gt;
&lt;p&gt;We&amp;#8217;ve used &lt;b&gt;score&lt;/b&gt; above as a measure of how close a name is to the &amp;#8220;seed&amp;#8221; name, but we&amp;#8217;ve not discussed how to actually do this. A usual way of doing this is counting changes (number of additions, alterations and deletions needed to make the names same). I&amp;#8217;ve done something similar, using &lt;i&gt;alignments&lt;/i&gt;. I generate all the &lt;i&gt;alignments&lt;/i&gt; of the two names and to score the best one.&lt;/p&gt;
&lt;p&gt;What is an alignment?&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
m i l i n d
+ | | | | |
n i l i n d
&lt;/pre&gt;
&lt;p&gt;The alignment above attempts to align &amp;#8220;milind&amp;#8221; to &amp;#8220;nilind&amp;#8221;. The &lt;code&gt;|&lt;/code&gt; denotes a &lt;i&gt;match&lt;/i&gt;, while the &lt;code&gt;+&lt;/code&gt; denotes a &lt;i&gt;mismatch&lt;/i&gt;. A &lt;i&gt;mismatch&lt;/i&gt; roughly hints towards an alteration.&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
m i l i n d
| _ | | | |
m   l i n d
&lt;/pre&gt;
&lt;p&gt;The alignment above attempts to align &amp;#8220;milind&amp;#8221; to &amp;#8220;mlind&amp;#8221;. The &lt;code&gt;|&lt;/code&gt; denotes a &lt;i&gt;match&lt;/i&gt;, while the &lt;code&gt;_&lt;/code&gt; denotes a &lt;i&gt;gap&lt;/i&gt;. A &lt;i&gt;gap&lt;/i&gt; roughly hints towards an addition or a deletion.&lt;/p&gt;
&lt;p&gt;There can be many alignments for any two names. For instance, for &amp;#8220;mil&amp;#8221; and &amp;#8220;lul&amp;#8221;, all the three alignments given below are valid.&lt;/p&gt;
&lt;pre class=&quot;src&quot;&gt;
m i l
_ _ | _ _
    l u l
score: -3

m i l
+ + |
l u l
score: 2

m i l
_ + + _
  l u l
score: -1
&lt;/pre&gt;
&lt;p&gt;Each of these alignments is assigned a score. For each &lt;i&gt;match&lt;/i&gt;, an alignment is given 1 point. For each &lt;i&gt;mismatch&lt;/i&gt;, an alignment is given 0.5 points, and for each &lt;i&gt;gap&lt;/i&gt;, an alignment is given -1 points. We calculate the score for all possible alignments, and choose the one with the best score. In the case above, it would be the second one.&lt;/p&gt;
&lt;p&gt;This method causes longer names to have better scores than smaller ones, because they simply have more matches. To remove the effect of name length on the score, we divide the best score by the length of the name.&lt;/p&gt;
&lt;p&gt;Thus, the score we talked about is defined as:&lt;/p&gt;
&lt;p&gt;$$ score = \frac{BestAlignmentScore(\text{name},\text{seed})}{\text{name}.length} $$&lt;/p&gt;
&lt;p&gt;Actually - that is not one hundred percent true, I&amp;#8217;ve simplified it a bit above.&lt;/p&gt;
&lt;p&gt;Firstly, I don&amp;#8217;t match names written down using the letters of the English alphabet. Instead, I use names written down using the &lt;a href=&quot;https://en.wikipedia.org/wiki/International_Phonetic_Alphabet&quot;&gt;International Phonetic Alphabet&lt;/a&gt; (IPA). In the English alphabet, the way we &lt;i&gt;write&lt;/i&gt; something and the way we &lt;i&gt;say&lt;/i&gt; it is quite different, and I aim to produce similar &lt;i&gt;sounding&lt;/i&gt; names. The IPA provides an easy, comprehensive way to represent how a word should be spoken out loud. At the same time, the IPA uses a rather large set of symbols, like &amp;#8216;É³&amp;#8217; and &amp;#8216;Î¸&amp;#8217; and so on. I have used ASCII representations instead, as described in this &lt;a href=&quot;http://www.antimoon.com/resources/phonchart2008.pdf&quot;&gt;very useful document&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Secondly, the &lt;i&gt;mismatch&lt;/i&gt; score is not a constant. Consider the two mismatches - (&lt;i&gt;a:&lt;/i&gt; as in &lt;i&gt;arm&lt;/i&gt;, &lt;i&gt;e:&lt;/i&gt; as in &lt;i&gt;turn&lt;/i&gt;) and (&lt;i&gt;a:&lt;/i&gt; as in arm, and &lt;i&gt;l&lt;/i&gt; as in &lt;i&gt;leg&lt;/i&gt;). The first pair consists of similar sounding vowels, while the second pair consists of one vowel and one consonant, which sound very different. Thus, the first pair gets a larger &lt;i&gt;mismatch&lt;/i&gt; score. The entire scheme of mismatch scores is decided by &lt;a href=&quot;https://docs.google.com/spreadsheets/d/1ZIsQbYccrpIz5iQXhU5XiEqSQkMNy888-vJO9vlvE98/edit?usp%3Dsharing&quot;&gt;this grid I came up  with&lt;/a&gt;. The gap score is also smaller, around -0.15 by default.&lt;/p&gt;
&lt;p&gt;Thirdly, the name and the &amp;#8220;seed&amp;#8221; might have different lengths. In particular, for a &amp;#8220;seed&amp;#8221; of length 6, the name might be 5-7 characters long. Thus, the final score definition actually looks somewhat different:&lt;/p&gt;
&lt;p&gt;$$ score = \frac{BestAlignmentScore(\text{name},\text{seed})}{Mean(\text{name}.length, \text{seed}.length)} $$&lt;/p&gt;
&lt;p&gt;The algorithm that finds the best alignment is mostly the same as the &lt;a href=&quot;Needleman-Wunsch%20Algorithm&quot;&gt;Needleman-Wunsch Algorithm&lt;/a&gt;, which is used to align protein sequences.&lt;/p&gt;
&lt;h1&gt;NPC-Name Generator in Action&lt;/h1&gt;
&lt;p&gt;This is an example run of the generator.
  Please feel free to try it out yourself at https://github.com/milindl/NPC-name&lt;/p&gt;
&lt;p&gt;Seed name: d ei v i d (DAVID)
  Generated names:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;d ei o: i d (DAOUID) (DAY - OO - EE - D)&lt;/li&gt;
  &lt;li&gt;d ei v i TH (DAVITH)&lt;/li&gt;
  &lt;li&gt;d ei v TH (DAVTH) (pretty much useless)&lt;/li&gt;
  &lt;li&gt;d ei v i e:(r) (DAVIER)&lt;/li&gt;
  &lt;li&gt;TH ei v i (THAYVI) (TH as in THIN)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clearly, not all of them are useable, but they&amp;#8217;re not useless either.&lt;/p&gt;
&lt;h1&gt;Future Work&lt;/h1&gt;
&lt;h2&gt;Asymmetric Grid&lt;/h2&gt;
&lt;p&gt;Currently, the grid used to score mismatches is symmetric. Thus, &lt;i&gt;a:&lt;/i&gt; turning to &lt;i&gt;e:&lt;/i&gt; is as likely as &lt;i&gt;e:&lt;/i&gt; turning to &lt;i&gt;a:&lt;/i&gt;. However, by changing this, I can model the flow of time. For instance, I want to model that over time, both the &lt;i&gt;Ê’&lt;/i&gt; (as in &lt;i&gt;pleaSure&lt;/i&gt;) and &lt;i&gt;z&lt;/i&gt; (as in &lt;i&gt;zoo&lt;/i&gt;) sounds being replaced with &lt;i&gt;z&lt;/i&gt;. In this case, I can make it more likely for &lt;i&gt;Ê’&lt;/i&gt; sound to change into &lt;i&gt;z&lt;/i&gt; than the other way around. This way, I can probably look at how a word changes over time.&lt;/p&gt;
&lt;h2&gt;Accurate Grid&lt;/h2&gt;
&lt;p&gt;Right now, the grid is based on me saying some words and comparing how similar they sound to me. Instead, I should base my grid &lt;a href=&quot;https://en.wikipedia.org/wiki/International_Phonetic_Alphabet#Consonants&quot;&gt;off this chart&lt;/a&gt;, which could help me describe the closeness of two symbols based on phonetic properties.&lt;/p&gt;
&lt;h2&gt;Neighboring-Letter Based Alignment&lt;/h2&gt;
&lt;p&gt;Certain letters occur together more often than not, and my program does not take that into account while computing alignment scoring. Thus, the alignment scores should depend not only on the letter, but also its neighboring letters.&lt;/p&gt;</content><author><name></name></author><summary type="html">On NPC Names</summary></entry><entry><title type="html">First Post</title><link href="/www/2017/05/31/test_post.html" rel="alternate" type="text/html" title="First Post" /><published>2017-05-31T00:00:00+05:30</published><updated>2017-05-31T00:00:00+05:30</updated><id>/www/2017/05/31/test_post</id><content type="html" xml:base="/www/2017/05/31/test_post.html">&lt;p&gt;The main purpose of this post was to check styles and make sure that org-mode is working,
  and any scripts I use for posting run alright.&lt;/p&gt;
&lt;p&gt;It has no real content, so there&amp;#8217;s no point to reading it, but thanks anyway.&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;re really interested in knowing who gets the Iron Throne, I would bet my dollar on the bastards.&lt;/p&gt;</content><author><name></name></author><summary type="html">The main purpose of this post was to check styles and make sure that org-mode is working, and any scripts I use for posting run alright.</summary></entry></feed>